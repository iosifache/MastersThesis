# Automatic Exploit Generation Module

**Automatic exploit generation** is the goal of the last module presented in this thesis. It is directly linked to two modules to receive its required data: the vulnerability detection one, to get the proofs of vulnerabilities (namely `ProofOfVulnerability` objects), and the vulnerability analytics one, to get further details about the exploitation context and exploitability.

## Theoretical Aspects

To determine the current academic progress in the automatic exploit generation field, we researched multiple papers related to this subject. All can be split into the following categories:

- Papers describing an AEG (sub)system [1] [2] [3] [4]: The majority of the studied papers approach the problem by coupling it with the vulnerability detection one. In such a way, the systems detect **weaknesses** in programs by leveraging diverse techniques and creating functional **exploits**.
- Papers summarizing the current AEG context [5] [6] [7]: This category does not present specific implementation of an AEG system, but reviews techniques and approaches that were proposed in functional cyber reasoning systems (for example, those from DARPA's Cyber Grand Challenge) and academia, as standalone exploitation research.

A summary of the most common weaknesses, mitigations, (support) exploitation techniques, and outcomes detailed or used in the studied papers are listed in below lists:

- **Weaknesses**
  - **Out-of-bound memory writes**: Consists of writing data whose length exceeds the buffer length. There are two types of allocation: on **stack**, for variables defined in a function, or **heap**, when the buffer is dynamically allocated. If the stack is targeted, then the **return address** and **old base pointer** can be overwritten.
  - **Type overflow**: The correct result of an operation could not be stored in a certain type of variable.
  - **Tainted format strings**: The first parameter of functions working with a format string (such as `printf`) is user controlled.
  - **Information leaks**: The program divulges information about its execution (for example, memory layout).
- **Mitigations**
  - **Address Space Layout Randomization** (abbreviated ASLR): Segments such as the stack, dynamic libraries, and heap are placed randomly in the process memory space.
  - **Position Independent Execution**: The code segment is placed, as in ASLR, randomly in the memory space. The program should be compiled with Position Independent Code enabled.
  - **NX bit**: If enabled, the bit prevents a page to be executed and writable at the same time.
  - **Stack canaries**: The canaries are values placed on the stack after entering a frame. It is checked on return and, if the check fails, then the execution is aborted.
  - **Control flow integrity**: Permits only certain code, part of the valid control flow graph, to be executed. New code, injected by attackers in process memory, could not be executed anymore.
- **Exploitation techniques (including support ones)**
  - **Shellcode**: Machine code is injected in process memory and executed by chaining with other techniques for hijacking the execution flow.
  - **Return-oriented programming**: Unlike shellcodes, which inject new code, ROPs reuse code already existent in process memory. A chain of gadgets is created and executed by coupling the technique with execution flow hijack.
  - **Data-oriented programming**: The accent in DOP resides on data flow and how it can be altered by using existent code constructs (similar to ROP).
  - **NOP sleds**: This support technique is used with shellcodes to increase the probability that it will be executed correctly. The shellcode is prefixed with a `nop` sequence such that the execution could be redirected (for example, with return address overwrites) anywhere on the sled. This is in contrast to raw shellcode when the execution needs to start from the first shellcode byte.
- **Outcomes**
  - **Code execution**: The programs execute the code desired by the attacker.
  - **Denial of service**: The program functioning is blocked or halted at all.
  - **Information leaks**: Sensitive information is extracted.

Regarding the full data flow and functioning of AEG systems, [4] can be seen as an example. It has an approach similar to what we have chosen for our cyber reasoning system. Firstly, the proposed system gets basic information about activated mitigations, such as NX bits and ASLR. After vulnerabilities are detected by their mining module, the protections are bypassed with returns to system libraries, in the case of NX bits, and `jmp esp` gadgets, as in ASLR bypass. Then an SMT solver is used to automatically build an exploit considering the constraints. The validation of the whole process was made with binaries from the Cyber Grand Challenge.

For OpenCRS, we researched the open-source space for projects which already have exploitation capabilities. Considering our focus on 32-bit, C-based ELF executables, we ended up with two candidates:

1. **Ropstar** [3]: Given an executable that takes input from files, and eventually has PIE, ASLR, NX, and canaries enabled, Ropstar attempts to exploit buffer overflows and improper uses of format strings to spawn a shell or to call a sensitive (or "win") function. Depending on the exploitation context, it may use techniques such as `.got` and `.plt` overwriting, and return-oriented programming (with return to `libc` or `.plt`, or direct `setuid` and `system` calls). Due to the limited input streams that are supported by default, we preferred to integrate the next detailed solution. It should be mentioned that, during the code review (for understanding the tool's internals), we discovered a command injection vulnerability, which we reported through a public issue [4] on GitHub. At the same time, a patch was proposed with a PR [5], which was not yet merged by the repository maintainer at the moment of writing this thesis.
2. **Zeratool** [6]: The second open-source solution that we analyzed (and the one we integrated) is Zeratool, a tool mainly for CTF challenges. Based on Radare [6], angr [7], and pwntools [8], it is capable to exploit **stack-based out-of-bounds writes** and format string weaknesses in binaries, but only the first was integrated because of the popularity of the weakness in C-based executables. The exploits bypass eventual mitigations such as **NX**, **PIE** and **ASLR**, and has the possible outcomes of:

   - **Code execution**
     - Sensitive functions: Functions with names containing strings such as "*secret*", "*shell*", and "*system*", can be called as some functionality relevant to an attacker can be unlocked;
     - Shellcodes;
     - Shell functions; and
   - **Leaking data from memory**, which can respect a Regex pattern that is set at the beginning of the exploitation.

### Implementation

OpenCRS modeled the concept of **exploiters**, which is a separate exploitation logic capable of generating exploits under specific conditions dictated by the input streams, mitigations, and outcomes. These are verified by the method `_is_exploitation_supported`, which should be implemented in each exploiter inheriting the `BaseExploiter` class.

In this way, the automatic exploitation module can use an **exploiters manager** to query all its exploiters to detect which can be used for a specific executable. The input streams and mitigations are already provided by the attack surface approximation module, and the outcomes are set in the CRS configuration.

As mentioned previously, Zeratool was integrated into OpenCRS as an exploiter by firstly forking the main repository [1] into a new repository in our organization, `zeratool_lib`. The initial codebase suffered modifications:

- The CLI was replaced with a unique function that can be called by the CRS modules. All relevant parameters (input stream, mode of exploitation, sensitive function, etc.) are exposed as parameters of this function.
- All remote exploitation logic was removed because of the local exploitation aspect of OpenCRS.
- The generated exploit is returned by the main function.
- `libpwnable`, a library used mainly for helping the exploitation, is no more an input stream. The only ones supported now are **`stdin`** and **arguments**.

If the query manager selects Zeratool as a suitable exploiter for a given scenario, then the sensitive functions are extracted. These are sent with the binary and its details via **gRPC** to a newly-created Docker **container**, where a Python 3 service will unpack them, and call `zeratool_lib`. If the exploitation process succeeds, the exploit is read and wrapped into an `Exploit` object.

> TODO: Add how the exploit is checked by running it.

## Testing

The module can be used as a Python module that can be used by OpenCRS. The other way is to run it as a CLI program, a method that we used to test the implemented features. The testing environment was an Ubuntu virtual machine with Docker already installed.

> TODO: Rephrase

```bash
➜ opencrs-exploit recommend --elf stdin_buffer_overflow.elf --stream STDIN --weakness STACK_OUT_OF_BOUND_WRITE
Exploiters that can be used considering the context are:
- ZERATOOL
➜ opencrs-exploit recommend --elf stdin_buffer_overflow.elf --stream STDIN --weakness STACK_OUT_OF_BOUND_WRITE --exploiter ZERATOOL
The exploiter could generate an exploit with the outcome of CALL_TO_WIN_FUNCTION and the following payloads:

- For STDIN:

00000000: 70 00 00 00 00 00 00 00  00 00 00 00 E5 00 00 CF  p...............
00000010: 6B 6D                                             km
```

> TODO: Update with a real example
