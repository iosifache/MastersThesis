# Automatic Exploit Generation Module

The last module given in this thesis aims towards automatic exploit generation. It is directly linked to two modules to obtain the data it requires: the vulnerability detection module, which provides proofs of vulnerabilities (specifically, `ProofOfVulnerability` objects), and the vulnerability analytics module, which provides further details about the exploitation circumstances and exploitability.

## Theoretical Aspects

We investigated several articles on the subject to determine the current academic development in the field of automatic exploit generation. All of them can be classified as follows:

- Papers describing an AEG (sub)system [1] [2] [3] [4]: The majority of the studies examined handle the problem by combining it with vulnerability detection. In this manner, the systems discover software flaws by combining several methodologies and developing functional exploits.
- Papers summarizing the current AEG context [5] [6] [7]: This category does not show specific AEG system implementations, but rather examines methodologies and approaches proposed in functional cyber reasoning systems (for example, those from DARPA's Cyber Grand Challenge) and academia as separate exploitation research.

The following lists provide a summary of the most common flaws, mitigations, (support) exploitation approaches, and consequences mentioned or used in the studied papers:

- Weaknesses
  - Out-of-bound memory writes: Consists of writing data whose length exceeds the buffer length. There are two types of allocation: on stack, for variables defined in a function, or heap, when the buffer is dynamically allocated. If the stack is targeted, then the return address and old base pointer can be overwritten.
  - Type overflow: The correct result of an operation could not be stored in a certain type of variable.
  - Tainted format strings: The first parameter of functions working with a format string (such as `printf`) is user controlled.
  - Information leaks: The program divulges information about its execution (for example, memory layout).
- Mitigations
  - Address Space Layout Randomization (abbreviated ASLR): Segments such as the stack, dynamic libraries, and heap are placed randomly in the process memory space.
  - Position Independent Execution: The code segment is placed, as in ASLR, randomly in the memory space. The program should be compiled with Position Independent Code enabled.
  - NX bit: If enabled, the bit prevents a page to be executed and writable at the same time.
  - Stack canaries: The canaries are values placed on the stack after entering a frame. It is checked on return and, if the check fails, then the execution is aborted.
  - Control flow integrity: Permits only certain code, part of the valid control flow graph, to be executed. New code, injected by attackers in process memory, could not be executed anymore.
- Exploitation techniques (including support ones)
  - Shellcode: Machine code is injected in process memory and executed by chaining with other techniques for hijacking the execution flow.
  - Return-oriented programming: Unlike shellcodes, which inject new code, ROPs reuse code already existent in process memory. A chain of gadgets is created and executed by coupling the technique with execution flow hijack.
  - Data-oriented programming: The accent in DOP resides on data flow and how it can be altered by using existent code constructs (similar to ROP).
  - NOP sleds: This support technique is used with shellcodes to increase the probability that it will be executed correctly. The shellcode is prefixed with a `nop` sequence such that the execution could be redirected (for example, with return address overwrites) anywhere on the sled. This is in contrast to raw shellcode when the execution needs to start from the first shellcode byte.
- Outcomes
  - Code execution: The programs execute the code desired by the attacker.
  - Denial of service: The program functioning is blocked or halted at all.
  - Information leaks: Sensitive information is extracted.

[4] is an example of the whole data flow and operation of AEG systems. It takes a similar approach to what we picked for our cyber reasoning system. To begin, the proposed method obtains basic information regarding active mitigations such as NX bits and ASLR. After their mining module detects vulnerabilities, the protections are circumvented via returns to system libraries in the case of NX bits and `jmp esp` gadgets in the case of ASLR bypass. Then, an SMT solver is utilized to automatically construct an exploit while taking the limitations into account. Binaries from the Cyber Grand Challenge were used to validate the entire process.

For OpenCRS, we looked into open-source projects that already have exploitation capabilities. Given our emphasis on 32-bit, C-based ELF executables, we came up with two candidates:

1. Ropstar [3]: Given an executable that accepts file input and eventually has PIE, ASLR, NX, and canaries enabled, Ropstar attempts to launch a shell or call a sensitive (or "win") function by exploiting buffer overflows and improper format string usage. It may utilize techniques such as `.got` and `.plt` overwriting, as well as return-oriented programming (with return to `libc` or `.plt`, or direct `setuid` and `system` calls) depending on the exploitation scenario. We choose to integrate the following sophisticated solution due to the limited input streams that are provided by default. It should be noted that we uncovered a command injection vulnerability during the code examination (to better understand the tool's internals), which we filed via a public issue [4] on GitHub. At the same time, a patch with a PR [5] was proposed, which had not yet been integrated by the repository maintainer at the time of writing this thesis.
2. Zeratool [6]: The second open-source option we investigated (and integrated) is Zeratool, which is primarily used for CTF challenges. It is capable of exploiting stack-based out-of-bounds writes and format string weaknesses in binaries, although only the first has been included due to the prominence of the weakness in C-based executables. The exploits avoid eventual mitigations like as NX, PIE, and ASLR, and have the potential to:

   - Code execution
     - Sensitive functions: Functions with names containing strings such as "*secret*", "*shell*", and "*system*", can be called as some functionality relevant to an attacker can be unlocked;
     - Shellcodes;
     - Shell functions; and
   - Leaking data from memory, which can respect a Regex pattern that is set at the beginning of the exploitation.

### Implementation

OpenCRS modeled exploiters, which are independent exploitation logic capable of generating exploits under specified parameters dictated by input streams, mitigations, and results. These are validated by the method `_is_exploitation_supported`, which should be implemented in every exploiter that derives from the `BaseExploiter` class.

In this manner, the automatic exploitation module can query all of its exploiters to determine which can be used for a certain executable using an exploiters manager. The attack surface approximation module already provides the input streams and mitigations, and the results are specified in the CRS configuration.

As previously stated, Zeratool was integrated into OpenCRS as an exploiter by first forking the main repository [1] into our organization's new repository, `zeratool_lib`. The original codebase was modified as follows:

- The CLI was replaced with a unique function that CRS modules can call. As parameters of this function, all necessary parameters (input stream, method of exploitation, sensitive function, etc.) are accessible.
- Because of the local exploitation element of OpenCRS, all remote exploitation logic was removed.
- The main function returns the produced exploit.
- `libpwnable`, a library primarily used to aid with exploitation, is no longer an input stream. The only ones that are now supported are `stdin` and arguments.

If the query manager chooses Zeratool as a suitable exploiter for a certain case, the sensitive functions are extracted. These are supplied together with the binaries and its details through gRPC to a freshly built Docker container, where a Python 3 service will unpack them and invoke `zeratool_lib`. If the exploitation procedure is successful, the exploit is read and wrapped into a `Exploit` object.
