# Automatic Exploit Generation Module

## Plan

- As a system
  - Input data structures
  - Output data structures
  - Exploiters
- Zeratool
  - Implementation (see `README.md`)
  - Zeratool fork
    - Removing remote attack capabilies
    - CLI to API
    - Interoperability
  - Automation of Zeratool
- Technologies
  - Docker
  - gRPC
- CLI

## Existing Content

\subsubsection{Introduction}

The automatic exploit generation module (abbreviated AEG) will be directly linked to other two modules in order to receive its required data. Firstly, the vulnerability detection module should detect a vulnerability and generate a proof of vulnerability (abbreviated PoV). The information about the PoV will be enriched by the vulnerability analytics module, adding details about context and exploitability.

To determine the current academic progress in the automatic exploit generation field, we researched multiple papers related to this subject. All can be split into the following categories:

\begin{itemize}
    \item Papers describing an AEG (sub)system \cite{aig} \cite{mayhem} \cite{bop} \cite{bof_aeg}: The majority of the studied papers approach the problem by coupling it with the vulnerability detection one. In such way, the systems detect \textbf{weaknesses} in programs by leveraging diverse techniques and creating functional \textbf{exploits}.
    \item Papers summarizing the current AEG context \cite{crs_aeg_survey} \cite{alphahacking} \cite{code_reuse_survey}: This category does not present specific implementation of an AEG system, but review techniques and approaches that were proposed in functional cyber reasoning systems (for example, those from DARPA's Cyber Grand Challenge) and academia, as standalone exploitation research.
\end{itemize}

A summary of the most common weaknesses, mitigations, (support) exploitation techniques, and outcomes detailed or used in the studied papers are listed in the below lists:

\begin{itemize}
    \item \textbf{Weaknesses} \begin{itemize}
        \item \textbf{Out-of-bound memory writes}: Consists of writing data whose length exceeds the buffer length. There are two types of allocation: on \textbf{stack}, for variables defined in function, or \textbf{heap}, when the buffer is dynamically allocated. If the stack is targeted, then the \textbf{return address} and \textbf{old base pointer} can be overwritten.
        \item \textbf{Type overflow}: The correct result of an operation could not be stored in a certain type of variables.
        \item \textbf{Tainted format strings}: The first parameter of functions working with a format string (such as \mintinline{text}{printf}) is user controlled.
        \item \textbf{Information leaks}: The program divulges information about its execution (for example, memory layout).
    \end{itemize}
    \item \textbf{Mitigations} \begin{itemize}
        \item \textbf{Address Space Layout Randomization} (abbreviated ASLR): Segments such as the stack, dynamic libraries, and heap are placed randomly in the process memory space.
        \item \textbf{Position Independent Execution}: The code segment is placed, as in ASLR, randomly in the memory space. The program should be compiled with Position Independent Code enabled.
        \item \textbf{NX bit}: If enabled, the bit prevents a page to be executable and writable in the same time.
        \item \textbf{Stack canaries}: The canaries are values placed on the stack after entering a frame. It is checked on return and, if the check fails, then the execution is aborted.
        \item \textbf{Control flow integrity}: Permits only certain code, part of the valid control flow graph, to be executed. New code, injected by attackers in process memory, could not be executed anymore.
    \end{itemize}
    \item \textbf{Exploitation techniques (including support ones)} \begin{itemize}
        \item \textbf{Shellcode}: Machine code is injected in process memory and executed by chaining with other technique for hijacking the execution flow.
        \item \textbf{Return-oriented programming}: Unlike shellcodes, which inject new code, ROPs reuse code already existent in process memory. A chain of gadgets is created and executed by coupling the technique with execution flow hijack.
        \item \textbf{Data-oriented programming}: The accent in DOP resides on data flow and how it can be altered by using existent code constructs (similar to ROP).
        \item \textbf{NOP sleds}: This support technique is used with shellcodes to increase the probability that it will be executed correctly. The shellcode is prefixed with a \mintinline{text}{nop} sequence such that the execution could be redirected (for example, with return address overwrites) anywhere on the sled. This is in contrast to raw shellcode, when the execution needs to start from the first shellcode byte.
    \end{itemize}
    \item \textbf{Outcomes} \begin{itemize}
        \item \textbf{Code execution}: The programs execute the code desired by the attacker.
        \item \textbf{Denial of service}: The program functioning is blocked or halted at all.
        \item \textbf{Information leaks}: Sensitive information is extracted.
    \end{itemize}
\end{itemize}

Regarding the full data flow and functioning of AEG systems, \cite{archr} can be seen as an example. It has an approach similar to what we have chosen for our cyber reasoning system. Firstly, the proposed system gets basic information about activated mitigations, such as NX bits and ASLR. After vulnerabilities are detected by their mining module, the protections are bypassed with returns to system libraries, in the case of NX bits, and \mintinline{text}{jmp esp} gadgets, as in ASLR bypass. Then an SMT solver is used to automatically build an exploit considering the constraints. The validation of the whole process was made with binaries from the Cyber Grand Challenge.

\subsubsection{Implementation}

As seen in the previous subsection, the landscape of the automatic exploit generation is vast. For OpenCRS, we selected a bunch of weaknesses and exploits to demonstrate the impact an automated exploitation can have:

\begin{itemize}
    \item \textbf{Mitigations}: NX bit and ASLR;
    \item \textbf{Weaknesses}: instruction pointer overwrite (leveraging a stack buffer overflow) and format string attacks;
    \item \textbf{Exploit techniques}, all with code execution as desired \textbf{outcome}: ret2win, shellcodes, and return-oriented programming;
\end{itemize}

The mitigation detection was implemented with the help of \textbf{pwntools}, a Python 3 binary exploitation package. In this manner, the automatic exploit generation module is able to detect usage of ASLR, NX bit, stack canaries, relocation read-only, Position Independent Code, FORTIFY-SOURCE, and Address Sanitizer.

Besides the mitigations, the target executable is further inspected by checking if \textbf{relevant characteristics} are present:

\begin{itemize}
    \item Segments that can be written, read, and executed: Can be leveraged during attacks with shellcodes, against buffer overflows. A shellcode can be put directly on the segment and the return address is overwritten with the address of the segment's beginning.
    \item An executable stack: Same as above, but the segment is in fact the whole stack, which contains a writable buffer.
    \item Sensitive functions: Functions with names containing strings such as "\textit{secret}", "\textit{shell}", and "\textit{system}", can be called as some functionality relevant to an attacker can be unlocked.
\end{itemize}

The single weakness tackled this semester is \textbf{instruction pointer overwrite}. After the vulnerability detection manages to overwrite the instruction pointer, the automatic exploit generation will firstly fingerprint the weakness by executing the following sequence of steps:

\begin{enumerate}
    \item Generate a random De Bruijn sequence (noted \mintinline{text}{<seq>}).
    \item  Run the executable with the generated sequences.
    \item  Get the value of the instruction pointer when the crash occurred (noted \mintinline{text}{<eip_subseq>}).
    \item  Deduce the offset between the buffer's start and the instruction pointer by finding \mintinline{text}{<eip_subseq>} in \mintinline{text}{<seq>}.
\end{enumerate}

In the current module version, the weakness is then exploited with \textbf{ret2win}. The program is run repeatedly with the addresses of the sensitive functions. The behavior should be then watched to detect non-secure actions: shell spawning, produced outputs, etc.

> Source: third report
