# Vulnerability Detection Module

The purpose of the **vulnerability detection module** is to use the information extracted by the **attack surface approximation module** (the inputs streams, the arguments, and their roles) to find vulnerabilities in executables. This process does not only conclude the possibility of a vulnerability occurring, but it produces an actual **proof of vulnerability** (i.e. an input that triggers the vulnerability) object, `ProofOfVulnerability`. It then will be passed outside of the module, namely to the **vulnerability analytics one**, to get the root cause and the affected internals of the executable.

Despite the fact this chapter treats only fuzzing for discovering vulnerabilities, "" [3] deals with integrating symbolic execution with Retdec [retdec] and KLEE [klee] in this module of OpenCRS.

## Theoretical Considerations

The issue that can emerge during the exploration of the executable and its execution is **path explosion**, a problem specific to techniques such as **symbolic execution**. As symbolic values are propagated on each path of the graph, the complexity of finding vulnerabilities in such a large set of data is unfeasible considering the limitations in memory and computation power.

We proceed to overcome this by using **fuzzing**. The sending of random inputs on each input stream makes the execution flow on various paths, with various input variables. The probability of triggering a vulnerability could be then increased.

Another important constraint for fuzzing is the **black-box** (or binary-only) aspect of the CRS: the vulnerability discovery module does not have access to the source code of the executable, but only to the binary itself. This limited our search as multiple fuzzers use source code instrumentation, namely introducing small pieces of code before the compilation stage such that, at execution, the fuzzer can know which path of the CFG was reached by the execution.

Firstly, we considered **american fuzzy lop** (abbreviated AFL) as a state-of-the-art blackbox fuzzer that we can integrate into the cyber reasoning system, but Google's upstream has had no development activity since June 2021 and the repository itself is archived. A promising alternative is a fork of it, **afl++**, which is continuously developed by the open-source community and supports features like:

- QEMU emulation for deducing relevant information (for example, coverage) on runtime, without a hard requirement for source code instrumentation before compilation;
- Persistent mode for specifying a section of the code segment that should be executed in a loop by the fuzzer, without the need of creating a process each time new inputs should be provided to the executable; and
- Greater speed, resulting in more mutations in the fuzzing engine.

## Implementation

Our implementation started by considering a subset of all possible input streams (files, standard input, and arguments) that an executable could have. This information is provided explicitly, when calling the vulnerability detection functionalities, and can be deduced via the attack surface approximation module.

As previously mentioned, afl++ was chosen as a blackbox fuzzing tool. We created a custom Docker image to be its environment, the goals being isolation and easy regeneration. The **QEMU support** for binaries-only fuzzing was activated by running the specific `build_qemu_support.sh` script.

It is instantiated by using the Docker API for Python, having the required volumes (for target executable, sample inputs, and analysis) automatically attached. Furthermore, the same Python code starts `afl-fuzz` inside the created **container** to fuzz the provided target executable with the sample inputs (if any). These are mutated and **passed to standard input or placed in files** (two input streams that are supported by default by afl++), data that is consumed by the binary.

When a new crash is detected by afl++ for `stdin` and files, a new file is created in the analysis directory (`/tmp/fuzzer/<session>/output/default/crashes/`), which is continuously monitored by a Python **watchdog**. The crash file is read to create a new instance of the class `ProofOfVulnerability`.

We used the same Docker image for **arguments fuzzing**. The main difference is that the fuzzed binary is not the target binary anymore, but a custom adapter built in C. The wrapper takes the random input generated by afl++ from `stdin`. Then, the input is tokenized by using space (`0x20` ASCII) as a delimiter and detects formatting placeholders (`%s`) that it replaces with the input generated by afl++. The resulting `char *` sequence is used as `argv` for an `execve` call.

The initial image of the process, as it is created by the fuzzer, is the adapter's image. By using the described approach, the syscall replaces the process image with the real target binary one, having as arguments a random string of characters. An argument's mismanagement can cause a crash, which will be detected and reported by afl++ to our watchdog.
